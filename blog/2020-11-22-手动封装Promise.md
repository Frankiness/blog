---
slug: promise
title: 手动封装Promise
author: 老谭
author_title: 前端工程师
author_url: https://github.com/ Frankiness
author_image_url: ../static/img/avatar.jpg
description: 手动封装Promise
tags: [前端, JavaScript,面试,手撕]
---

`Promise` 对象是由关键字 `new` 及其构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——`resolve` 和 `reject` ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 `resolve` 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用`reject` 函数。
```javascript
new Promise((resolve,reject)=>{	//整个回调函数就是处理器函数
  resolve('success')		//resolve和reject都是函数调用
  reject('fail')
})
```
<!-- truncate -->
- Promise有三种状态：pending、resolve和reject
- Promise构造函数上的方法有：resolve、reject等
- Promise原型对象上的方法有：then、catch、finally
### 简单封装Promise以及then，catch函数
```javascript
function MyPromise(fn) {
  let that = this
  that.value = ''
  that.status = 'pending' //定义初始状态
  //resolve函数
  function resolve(value) {
    if (that.status === 'pending') {
      that.status = 'resolved'
      that.value = value
    }
  }
  //reject函数
  function reject(value) {
    if (that.status === 'pending') {
      that.status = 'rejected'
      that.value = value
    }
  }
  //函数立即执行器
  fn(resolve, reject)
}
//在原型上定义then,catch
MyPromise.prototype.then = function (OnResolve, OnReject) {
  let that = this
  //如果传入的参数不是函数或者为null，那就将这个参数封装成函数
  if (typeof OnReject != 'function') {
    OnReject = () => {}
  }
  if (typeof OnResolve != 'function') {
    OnResolve = () => {}
  }
  //判断传入的参数的状态
  if (that.status === 'resolved') {
    //捕获错误
    try {
      let that = this
      OnResolve(that.value)
    } catch (error) {
      OnReject(error)
    }
  }
  if (that.status === 'rejected') {
    try {
      let that = this
      OnReject(that.value)
    } catch (error) {
      OnReject(error)
    }
  }
}

let p = new MyPromise((resolve, reject) => {
    resolve('success')
    reject('fail')
  })
  .then((res) => {
    console.log(res);
  }, (err) => {
    console.log(err);
  })
```
### 实现Promise.all方法
**要点：**

1. `all`方法返回的也是`promise`对象
1. 遍历每个元素，要所有`promise`都成功了才能`resolve`
1. 有一个失败直接`reject`
1. 使用一个数组记录`then`的`res`个数，当数组长度与传入参数长度相等时，即`resolve`
1. 传入参数有可能不是`promise`对象，所以使用`Promise.resolve(item)`将其包装成`promise`
```javascript
function Myall(promiseArr) {
  const values = []		//记录数组
  return new Promise((resolve, reject) => {
    promiseArr.forEach((item, idnex) => {
      Promise.resolve(item).then(res => {		//包装遍历元素
        values.push(res)			//成功即压入数组记录
        if (values.length == promiseArr.length) {		//全部遍历完成就resolve
          resolve(res)
        }
      }, err => {
        reject(err)
      })
    })
  })
}
```
### 实现Promise.race方法
谁先执行完成就先返回谁的状态，不管成功还是失败
```javascript
function Myrace(promiseArr){
  return new Promise((resolve,reject)=>{
    promiseArr.forEach((item,index)=>{
      item.then(res=>{
        resolve(res)
      },err=>{
        reject(err)
      })
    })
  })
}
```
### 实现finally方法
```javascript
Promise.prototype.finally = function(cb)=>{
  return this.then(res=>{
    Promise.resolve(cb()).then(()=>res),
    Promise.resolve(cb()).then(()=>{
      throw error
    })
  })
}
```
